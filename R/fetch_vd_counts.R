#' @title Fetch VecDyn dataset length by ID
#' @description Retrieve length of VecDyn dataset/s specified by their dataset ID.
#' @author Francis Windram
#'
#' @param ids a numeric ID or numeric vector of ids (preferably in an `ohvbd.ids` object) indicating the particular dataset/s to download.
#' @param rate maximum number of calls to the API per second.
#' @param connections number of simultaneous connections to the server at once. Maximum 8. **Do not enable unless you really need to** as this hits the server significantly harder than usual.
#' @param page_size the page size returned by VecDyn (default is 50).
#' @param basereq an [httr2 request][httr2::request()] object, as generated by [vb_basereq()]. If `NA`, uses the default request.
#'
#' @return A dataframe describing the number of rows and number of pages for the set of ids
#'
#' @examples
#' \dontrun{
#' fetch_vd_counts(54)
#'
#' fetch_vd_counts(c(423,424,425), rate=5)
#' }
#'
#' @concept vecdyn
#'
#' @export
#'

fetch_vd_counts <- function(ids, rate = 5, connections = 2, page_size = 50, basereq = NA) {
  max_conns <- 8

  if (is.null(attr(ids, "db"))) {
    cli_alert_warning("IDs not necessarily from VecDyn.")
  } else if (attr(ids, "db") != "vd") {
    cli_abort(c("x" = "IDs not from VecDyn, Please use the {.fn fetch_{attr(ids, 'db')}} function.", "!" = "Detected db = {.val {attr(ids, 'db')}}"))
  }

  if (all(is.na(basereq))) {
    basereq <- vb_basereq()
  }

  if (length(ids) > 10) {
    # Preflight ssl check
    status <- tryCatch({
      preflight_test <- basereq |> req_perform()  # nolint: object_usage_linter
      list("err_code" = 0, "err_obj" = NULL)
    }, error = function(e) {
      list("err_code" = 1, "err_obj" = e)
    })

    if (status$err_code == 1) {
      curl_err <- get_curl_err(status$err_obj, returnfiller = TRUE)
      if (grepl("SSL certificate problem: unable to get local issuer certificate", curl_err)) {
        cat("\n")
        cli_alert_danger("Could not verify SSL certificate.")
        cli::cli_text("You may have success running {.fn set_ohvbd_compat} and then trying again.")
        cat("\n")
        cli_abort("SSL certificate problem: unable to get local issuer certificate")
      } else {
        cli_abort("Preflight found unknown error: {.val {curl_err}}")
      }
    }
  }

  count_reqs <- ids |> lapply(\(id) {
    basereq |>
      req_url_path_append("vecdyncsv") |>
      req_url_query("format" = "json", "piids" = id) |>
      req_error(body = vd_error_body) |>
      req_headers(ohvbd = id) |>  # Add additional header just so we can nicely handle failures
      req_throttle(rate)
  })

  if (connections > max_conns) {
    cli_alert_warning("No more than {.val {max_conns}} simultaneous connection{?s} allowed!")
    cli_alert_info("Restricting to {.val {max_conns}} connection{?s}.")
    connections <- max_conns
  }
  count_resps <- count_reqs |> req_perform_parallel(on_error = "continue", max_active = connections, progress = list(
    name = "VecDyn data counts",
    format = "Finding {cli::pb_name} {cli::pb_current}/{cli::pb_total} {cli::pb_bar} {cli::pb_percent} | ETA: {cli::pb_eta}"
  ))

  # Find counts and calculate required pages
  resp_parsed <- count_resps |>
    lapply(\(resp) resp_body_json(resp)$count) |>
    as.numeric()
  resp_parsed <- data.frame(id = ids, num = resp_parsed)
  resp_parsed$pages <- ceiling(resp_parsed$num / page_size)
  return(resp_parsed)
}
