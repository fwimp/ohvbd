#' @title Get and parse multiple VecTraits datasets by ID in chunks
#' @description Retrieve and parse VecTraits datasets specified by their dataset IDs in batches.
#'
#' This is not usually necessary (generally you just need [fetch_vt()]) but allows one to release data that is not in use from memory. If you would like more control on extraction or parsing then it is best to wrap [fetch_vt()] and [extract_vt()] in your own chunker instead.
#' @author Francis Windram
#'
#' @param ids a numeric vector of IDs (preferably in an `ohvbd.ids` object) indicating the particular datasets to download.
#' @param chunksize an integer defining the size of chunks to retrieve in one iteration.
#' @param cols a character vector of columns to extract from the dataset.
#' @param returnunique whether to return only the unique rows within each dataset according to the filtered columns.
#' @param rate maximum number of calls to the API per second.
#' @param connections number of simultaneous connections to the server at once. Maximum 8. **Do not enable unless you really need to** as this hits the server significantly harder than usual.
#' @param basereq an [httr2 request][httr2::request()] object, as generated by [vb_basereq()]. If `NA`, uses the default request.
#'
#' @return An `ohvbd.data.frame` containing the requested data.
#'
#' @examples
#' \dontrun{
#' fetch_extract_vt_chunked(c(54,55,56), chunksize = 2, rate=5)
#' }
#'
#' @concept vectraits
#'
#' @export
#'

fetch_extract_vt_chunked <- function(ids, chunksize = 20, cols = NA, returnunique = FALSE, rate = 5, connections = 2, basereq = NA) {

  if (is.null(attr(ids, "db"))) {
    cli_alert_warning("IDs not necessarily from VecTraits.")
  } else if (attr(ids, "db") != "vt") {
    cli_abort(c("x" = "IDs not from VecTraits, Please use the appropriate {.fn fetch_extract_{attr(ids, 'db')}} function.", "!" = "Detected db = {.val {attr(ids, 'db')}}"))
  }

  if (all(is.na(basereq))) {
    basereq <- vb_basereq()
  }

  if (length(ids) > 10) {
    # Preflight ssl check
    status <- tryCatch({
      preflight_test <- basereq %>% req_perform()  # nolint: object_usage_linter
      list("err_code" = 0, "err_obj" = NULL)
    }, error = function(e) {
      list("err_code" = 1, "err_obj" = e)
    })

    if (status$err_code == 1) {
      curl_err <- get_curl_err(status$err_obj, returnfiller = TRUE)
      if (grepl("SSL certificate problem: unable to get local issuer certificate", curl_err)) {
        cat("\n")
        cli_alert_danger("Could not verify SSL certificate.")
        cli::cli_text("You may have success running {.fn set_ohvbd_compat} and then trying again.")
        cat("\n")
        cli_abort("SSL certificate problem: unable to get local issuer certificate")
      } else {
        cli_abort("Preflight found unknown error: {.val {curl_err}}")
      }
    }
  }

  # Get and extract vt data by ID in chunks (to save memory)

  # Split into chunks
  breakpoints <- seq(0, length(ids) + (chunksize - 1), by = chunksize)
  chunks <- cut(seq_along(ids), breaks = breakpoints, labels = FALSE)
  chunklets <- split(ids, chunks)

  # Lapply pipeline to chunk list
  out_list <- chunklets %>% lapply(\(idchunk) {
    fetch_vt(idchunk, rate = rate, connections = connections, basereq = basereq) %>%
      extract_vt(cols = cols, returnunique = returnunique)
  })

  out_df <- suppressWarnings(rbindlist(out_list))

  out_final <- as.data.frame(out_df)
  out_final <- new_ohvbd.data.frame(df = out_final, db = "vt")

  return(out_final)
}
