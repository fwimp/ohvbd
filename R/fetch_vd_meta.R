#' Find vecdyn metadata
#'
#' @param ids a numeric ID or numeric vector of ids (preferably in an `ohvbd.ids` object) indicating the particular dataset/s to download.
#' @param rate maximum number of calls to the API per second.
#' @param connections number of simultaneous connections to the server at once. Maximum 8. **Do not enable unless you really need to** as this hits the server significantly harder than usual.
#' @param pb_name the name of the download progress bar
#' @param basereq an [httr2 request][httr2::request()] object, as generated by [vb_basereq()]. If `NA`, uses the default request.
#'
#' @returns list of `httr2::response` object
#'
#' @keywords internal
fetch_vd_meta <- function(
  ids,
  rate = 5,
  connections = 2,
  pb_name = "data",
  basereq = NA
) {
  max_conns <- 8

  if (!has_db(ids)) {
    cli::cli_alert_warning("IDs not necessarily from VecDyn.")
  } else if (!is_from(ids, "vd")) {
    cli::cli_abort(c(
      "x" = "IDs not from VecDyn, Please use the {.fn fetch_{get_db(ids)}} function.",
      "!" = "Detected db = {.val {get_db(ids)}}"
    ))
  }

  if (all(is.na(basereq))) {
    basereq <- vb_basereq()
  }

  reqs <- ids |>
    lapply(\(id) {
      basereq |>
        req_url_path_append("vecdyncsv") |>
        req_url_query("format" = "json", "piids" = id) |>
        req_error(body = vd_error_body) |>
        req_headers(ohvbd = id) |> # Add additional header just so we can nicely handle failures
        req_throttle(rate)
    })

  if (connections > max_conns) {
    cli::cli_alert_warning(
      "No more than {.val {max_conns}} simultaneous connection{?s} allowed!"
    )
    cli::cli_alert_info("Restricting to {.val {max_conns}} connection{?s}.")
    connections <- max_conns
  }
  resps <- reqs |>
    req_perform_parallel(
      on_error = "continue",
      max_active = connections,
      progress = list(
        name = pb_name,
        format = "Finding {cli::pb_name} {cli::pb_current}/{cli::pb_total} {cli::pb_bar} {cli::pb_percent} | ETA: {cli::pb_eta}"
      )
    )
  return(resps)
}

#' @title Fetch VecDyn dataset length by ID
#' @description Retrieve length of VecDyn dataset/s specified by their dataset ID.
#' @author Francis Windram
#'
#' @param ids a numeric ID or numeric vector of ids (preferably in an `ohvbd.ids` object) indicating the particular dataset/s to download.
#' @param rate maximum number of calls to the API per second.
#' @param connections number of simultaneous connections to the server at once. Maximum 8. **Do not enable unless you really need to** as this hits the server significantly harder than usual.
#' @param page_size the page size returned by VecDyn (default is 50).
#' @param basereq an [httr2 request][httr2::request()] object, as generated by [vb_basereq()]. If `NA`, uses the default request.
#'
#' @return A dataframe describing the number of rows and number of pages for the set of ids.
#'
#' @examplesIf interactive()
#' fetch_vd_counts(54)
#'
#' fetch_vd_counts(c(423,424,425))
#'
#' @concept vecdyn
#'
#' @export
#'

fetch_vd_counts <- function(
  ids,
  rate = 5,
  connections = 2,
  page_size = 50,
  basereq = NA
) {
  count_resps <- fetch_vd_meta(
    ids,
    rate,
    connections,
    basereq,
    pb_name = "VecDyn data counts"
  )

  # Find counts and calculate required pages
  resp_parsed <- count_resps |>
    lapply(\(resp) resp_body_json(resp)$count) |>
    as.numeric()
  resp_parsed <- data.frame(id = ids, num = resp_parsed)
  resp_parsed$pages <- ceiling(resp_parsed$num / page_size)
  return(resp_parsed)
}
