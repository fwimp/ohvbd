#' @title Get and parse multiple VecDyn datasets by ID in chunks
#' @description Retrieve and parse VecDyn datasets specified by their dataset IDs in batches.
#'
#' This is not usually necessary (generally you just need [get_vd_byid()]) but allows one to release data that is not in use from memory. If you would like more control on extraction or parsing then it is best to wrap [get_vd_byid()] and [extract_vd_data()] in your own chunker instead.
#' @author Francis Windram
#'
#' @param basereq an [httr2 request][httr2::request()] object, as generated by [generate_vb_basereq()].
#' @param ids a numeric vector of IDs indicating the particular datasets to download.
#' @param chunksize an integer defining the size of chunks to retrieve in one iteration.
#' @param cols a character vector of columns to extract from the dataset.
#' @param returnunique whether to return only the unique rows within each dataset according to the filtered columns.
#' @param rate maximum number of calls to the API per second.
#'
#' @return A dataframe containing the requested data.
#'
#' @examples
#' \dontrun{
#' generate_vb_basereq() %>%
#'   get_extract_vd_byid_chunked(c(423,424,425), chunksize = 2, rate=5)
#' }
#'
#' @export
#'

get_extract_vd_byid_chunked <-
function(basereq, ids, chunksize=20, cols=NA, returnunique=FALSE, rate=5){
  # Get and extract vt data by ID in chunks (to save memory)

  # Split into chunks
  breakpoints <- seq(0, length(ids) + (chunksize-1), by = chunksize)
  chunks <- cut(seq_along(ids), breaks=breakpoints , labels=FALSE)
  chunklets <- split(ids, chunks)

  # Lapply pipeline to chunk list
  out_list <- chunklets %>% lapply(
    \(idchunk) basereq %>%
      get_vd_byid(idchunk, rate=rate) %>%
      extract_vd_data(cols=cols, returnunique=returnunique))

  out_df <- rbindlist(out_list, fill = TRUE)


  return(as.data.frame(out_df))
}
