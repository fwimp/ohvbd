#' @title Search VecDyn using the explorer's filters
#' @description Retrieve the IDs for any VecDyn datasets matching the given filter.
#'
#' @author Francis Windram
#'
#' @param basereq an [httr2 request][httr2::request()] object, as generated by [vb_basereq()].
#' @param field a field of VecDyn to search.
#' @param operator an operator to use when searching.
#' @param value the value that the field might/might not be.
#'
#' @section Valid fields:
#' The following field names are valid (shortcut names are listed in brackets):
#' - `SpeciesName` (*species*)
#' - `Title`
#' - `Collections`
#' - `Years` (*yrs*)
#' - `CollectionMethods` (*methods*)
#'
#' @section Valid operators:
#' The following operators are valid (alternative names are listed in brackets):
#' - `contains` (*contain, has, have*)
#' - `!contains` (*!contains, !has, !have, ncontains*)
#' - `equals` (*=, ==, equal, eq*)
#' - `!equals` (*!=, not, !equal, !eq, neq*)
#' - `starts` (*starts with, start with, start, sw*)
#' - `!starts` (*not starts with, not start with, !start, nsw*)
#' - `in` (*within*)
#' - `!in` (*not in, not within, !within, nin*)
#' - `greater` (*greater than, gt, >*)
#' - `less` (*less than, lt, <*)
#'
#' @return A numeric vector of VecDyn dataset IDs.
#'
#' @examples
#' \dontrun{
#' vb_basereq() %>%
#'   search_vd_smart("Collections", "gt", "1000")
#' }
#'
#' @export
#'

search_vd_smart <-
function(basereq, field, operator, value){
  # Operator lookup table.
  poss_operators <- c(
    "contains"=1, "contain"=1, "has"=1, "have"=1,
    "!contains"=2, "!contain"=2, "!has"=2, "!have"=2, "ncontains"=2,
    "="=3, "=="=3, "equal"=3, "equals"=3, "eq"=3,
    "!="=4, "not"=4, "!equal"=4, "!equals"=4, "!eq"=4, "neq"=4,
    "starts with"=5, "start with"=5, "start"=5, "starts"=5, "sw"=5,
    "not starts with"=6, "not start with"=6, "!start"=6, "!starts"=6, "nsw"=6,
    "in"=7, "within"=7,
    "not in"=8, "!in"=8, "not within"=8, "!within"=8, "nin"=8,
    "greater than"=9, "greater"=9, "gt"=9, ">"=9,
    "less than"=10, "less"=10, "lt"=10, "<"=10)
  final_operators <- c("contains", "ncontains", "eq", "neq", "sw", "nsw", "in", "nin", "gt", "lt")

  # Translate operator to proper operator name
  operator <- tolower(operator)
  if (operator %in% names(poss_operators)){
    final_operator <- final_operators[poss_operators[operator]]
  } else {
    # Just for warning message
    human_operators <- c("contains", "!contains", "equals", "!equals", "starts", "!starts", "in", "!in", "greater", "less")
    warning(paste(
      "Operator",
      operator,
      'not an allowed operator!\n  Allowed operators:\n  -',
      paste(human_operators, collapse = ",\n  - "),
      '\nDefaulting to "contains"...'))
    final_operator <- "contains"
    # TODO: Could add fuzzy matching using stringdist if that seems necessary
  }

  # Fields lookup table
  poss_fields <- c(
    "speciesname"=1, "species"=1,
    "title"=2,
    "collections"=3,
    "years"=4, "yrs"=4,
    "collectionmethods"=5, "methods"=5)
  final_fields <- c("SpeciesName", "Title", "Collections", "Years", "CollectionMethods")

  # Translate field to proper field name
  field <- tolower(field)
  if (field %in% names(poss_fields)){
    final_field <- final_fields[poss_fields[field]]
  } else {
    stop(paste("\n  Field",
               field,
               'not an allowed field!\n  Allowed fields:\n  -',
               paste(final_fields, collapse = ",\n  - "),
               '\nHalting execution.\n'))
  }
  resp <- tryCatch({
    resp <- basereq %>%
      req_url_path_append("vecdynbyprovider") %>%
      req_url_query("format" = "json") %>%
      req_url_query("field" = final_field) %>%
      req_url_query("operator" = final_operator) %>%
      req_url_query("term" = value) %>%
      req_perform()
    resp
  }, error = function(e){
    # Get the last response instead
    last_response()
  })

  if (resp$status_code == 404){
    stop(paste("No records found for", field, operator, value))
  }

  body <- resp %>% resp_body_json()
  if (length(body) > 2){
    # This is a bit of a kludge, the API does not return count in the same place if no results are found
    stop(paste("No records found for", paste(keywords, collapse = " ")))
  } else {
    return(as.numeric(body$ids))
  }
}
