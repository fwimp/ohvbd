#' @title Get and parse multiple VecTraits datasets by ID in chunks
#' @description Retrieve and parse VecTraits datasets specified by their dataset IDs in batches.
#'
#' This is not usually necessary (generally you just need [get_vt_byid()]) but allows one to release data that is not in use from memory. If you would like more control on extraction or parsing then it is best to wrap [get_vt_byid()] and [extract_vt_data()] in your own chunker instead.
#' @author Francis Windram
#'
#' @param ids a numeric vector of IDs indicating the particular datasets to download.
#' @param chunksize an integer defining the size of chunks to retrieve in one iteration.
#' @param cols a character vector of columns to extract from the dataset.
#' @param returnunique whether to return only the unique rows within each dataset according to the filtered columns.
#' @param rate maximum number of calls to the API per second.
#' @param basereq an [httr2 request][httr2::request()] object, as generated by [vb_basereq()]. If `NA`, uses the default request.
#'
#' @return A dataframe containing the requested data.
#'
#' @examples
#' \dontrun{
#' get_extract_vt_byid_chunked(c(54,55,56), chunksize = 2, rate=5)
#' }
#'
#' @export
#'

get_extract_vt_byid_chunked <- function(ids, chunksize = 20, cols = NA, returnunique = FALSE, rate = 5, basereq = NA) {

  if (all(is.na(basereq))) {
    basereq <- vb_basereq()
  }

  # Get and extract vt data by ID in chunks (to save memory)

  # Split into chunks
  breakpoints <- seq(0, length(ids) + (chunksize - 1), by = chunksize)
  chunks <- cut(seq_along(ids), breaks = breakpoints, labels = FALSE)
  chunklets <- split(ids, chunks)

  # Lapply pipeline to chunk list
  out_list <- chunklets %>% lapply(\(idchunk) {
    get_vt_byid(idchunk, rate = rate, basereq = basereq) %>%
      extract_vt_data(cols = cols, returnunique = returnunique)
  })

  out_df <- rbindlist(out_list)


  return(as.data.frame(out_df))
}
