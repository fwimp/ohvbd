#' @title Get VecDyn dataset/s by ID
#' @description Retrieve VecDyn dataset/s specified by their dataset ID.
#' @author Francis Windram
#'
#' @param ids a numeric ID or numeric vector of ids indicating the particular dataset/s to download.
#' @param rate maximum number of calls to the API per second.
#' @param connections number of simultaneous connections to the server at once. Maximum 8. **Do not enable unless you really need to** as this hits the server significantly harder than usual.
#' @param check_src toggle pre-checking of source data prior to get.
#' @param basereq an [httr2 request][httr2::request()] object, as generated by [vb_basereq()]. If `NA`, uses the default request.
#'
#' @return A list of [httr2 response][httr2::response()] objects.
#'
#' @examples
#' \dontrun{
#' get_vd(54)
#'
#' get_vd(c(423,424,425), rate=5)
#' }
#'
#' @concept vecdyn
#'
#' @export
#'

get_vd <- function(ids, rate = 5, connections = 1, check_src = TRUE, basereq = NA) {

  max_conns <- 8

  if (is.null(attr(ids, "db")) && check_src) {
    cli_alert_warning("IDs not necessarily from VecDyn.")
  } else if (attr(ids, "db") != "vd" && check_src) {
    cli_abort(c("x" = "IDs not from VecDyn, Please use the {.fn get_{attr(ids, 'db')}} function.", "!" = "Detected db = {.val {attr(ids, 'db')}}"))
  }

  if (all(is.na(basereq))) {
    basereq <- vb_basereq()
  }

  # vd does not return nonexistent piids as 404,
  reqs <- ids %>% lapply(\(id) {
    basereq %>%
      req_url_path_append("vecdyncsv") %>%
      req_url_query("format" = "json", "piids" = id) %>%
      req_error(body = vd_error_body) %>%
      req_headers(ohvbd = id) %>%  # Add additional header just so we can nicely handle failures
      req_throttle(rate)
  })
  if (connections <= 1) {
    resps <- reqs %>% req_perform_sequential(on_error = "continue", progress = list(
      name = "VecDyn Data",
      format = "Downloading {cli::pb_name} {cli::pb_current}/{cli::pb_total} {cli::pb_bar} {cli::pb_percent} | ETA: {cli::pb_eta}"
    ))
  } else {
    if (connections > max_conns) {
      cli_alert_warning("No more than {.val {max_conns}} simultaneous connection{?s} allowed!")
      cli_alert_info("Restricting to {.val {max_conns}} connection{?s}.")
      connections <- max_conns
    }
    resps <- reqs %>% req_perform_parallel(on_error = "continue", pool = curl::new_pool(total_con = 100, host_con = connections), progress = list(
      name = "VecDyn Data Parallel",
      format = "Downloading {cli::pb_name} {cli::pb_current}/{cli::pb_total} {cli::pb_bar} {cli::pb_percent} | ETA: {cli::pb_eta}"
    ))
  }

  attr(resps, "db") <- "vd"

  return(resps)
}
