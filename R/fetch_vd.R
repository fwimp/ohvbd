#' @title Fetch VecDyn dataset/s by ID
#' @description Retrieve VecDyn dataset/s specified by their dataset ID.
#' @author Francis Windram
#'
#' @param ids a numeric ID or numeric vector of ids (preferably in an `ohvbd.ids` object) indicating the particular dataset/s to download.
#' @param rate maximum number of calls to the API per second.
#' @param connections number of simultaneous connections to the server at once. Maximum 8. **Do not enable unless you really need to** as this hits the server significantly harder than usual.
#' @param basereq an [httr2 request][httr2::request()] object, as generated by [vb_basereq()]. If `NA`, uses the default request.
#'
#' @return A list of [httr2 response][httr2::response()] objects, as an `ohvbd.responses` object.
#'
#' @examples
#' \dontrun{
#' fetch_vd(54)
#'
#' fetch_vd(c(423,424,425), rate=5)
#' }
#'
#' @concept vecdyn
#'
#' @export
#'

fetch_vd <- function(ids, rate = 5, connections = 2, basereq = NA) {

  max_conns <- 8

  if (is.null(attr(ids, "db"))) {
    cli_alert_warning("IDs not necessarily from VecDyn.")
  } else if (attr(ids, "db") != "vd") {
    cli_abort(c("x" = "IDs not from VecDyn, Please use the {.fn fetch_{attr(ids, 'db')}} function.", "!" = "Detected db = {.val {attr(ids, 'db')}}"))
  }

  if (all(is.na(basereq))) {
    basereq <- vb_basereq()
  }

  if (length(ids) > 10) {
    # Preflight ssl check
    status <- tryCatch({
      preflight_test <- basereq |> req_perform()  # nolint: object_usage_linter
      list("err_code" = 0, "err_obj" = NULL)
    }, error = function(e) {
      list("err_code" = 1, "err_obj" = e)
    })

    if (status$err_code == 1) {
      curl_err <- get_curl_err(status$err_obj, returnfiller = TRUE)
      if (grepl("SSL certificate problem: unable to get local issuer certificate", curl_err)) {
        cat("\n")
        cli_alert_danger("Could not verify SSL certificate.")
        cli::cli_text("You may have success running {.fn set_ohvbd_compat} and then trying again.")
        cat("\n")
        cli_abort("SSL certificate problem: unable to get local issuer certificate")
      } else {
        cli_abort("Preflight found unknown error: {.val {curl_err}}")
      }
    }
  }
  resp_parsed <- fetch_vd_counts(ids, rate, connections, 50, basereq)
  cli::cli_alert_info("Found {.val {sum(resp_parsed$num)}} row{?s} of data.")
  # Found by fitting an exponential using nls to the performance benchmarks
  predicted_time <- lubridate::as.duration(lubridate::seconds(ceiling(sum(resp_parsed$num) * (0.01340331 * exp(-0.32535609*min(connections, 5))))))  # nolint: object_usage_linter
  cli::cli_alert_info("Predicted to take ~{.val {predicted_time}}.")

  basereq_url <- basereq$url  # Should always be set!
  basereq_useragent <- basereq$options$useragent %||% ""
  basereq_unsafe <- !is.null(basereq$options$ssl_verifypeer)

  # Construct a df containing one row with all appropriate params for each request, and then generate reqs for parallel requesting
  reqs_df <- resp_parsed |> dplyr::group_by(.data$id) |> dplyr::mutate(pages = list(seq(1, .data$pages))) |> tidyr::unnest(cols = c(.data$pages)) |> dplyr::ungroup()
  reqs <- mapply(vd_make_req, reqs_df$id, reqs_df$pages, 5, basereq_url, basereq_useragent, basereq_unsafe, SIMPLIFY = FALSE)

  if (connections > max_conns) {
    cli_alert_warning("No more than {.val {max_conns}} simultaneous connection{?s} allowed!")
    cli_alert_info("Restricting to {.val {max_conns}} connection{?s}.")
    connections <- max_conns
  }
  resps <- reqs |> req_perform_parallel(on_error = "continue", pool = curl::new_pool(total_con = 100, host_con = connections), progress = list(
    name = "VecDyn Data",
    format = "Downloading {cli::pb_name} {cli::pb_current}/{cli::pb_total} {cli::pb_bar} {cli::pb_percent} | ETA: {cli::pb_eta}"
  ))

  fails <- resps |> httr2::resps_failures()

  # Test if any failures were missing files (not 404s here, but counts of 0)
  missing <- find_vd_missing(resps)

  if (!is.null(missing)) {
    cli_alert_info("Incorrect ids:")
    cli::cli_ul(missing)

    # Need an extra check here because failed VD calls don't become 404s.
    if (length(missing) >= length(resps)) {
      cli_alert_warning("No records retrieved (are you sure the IDs are correct?).")
    }
  }

  # Return the curl errors
  curl_err <- unique(unlist(lapply(fails, get_curl_err)))
  if (!is.null(curl_err)) {
    cli_alert_warning("curl errors: {.val {curl_err}}")
  }

  # Test to see if we got only errors
  if (length(fails) >= length(resps)) {
    # Only got errors!
    # Test to see if we got only a bunch of ssl errors
    if (any(grepl("SSL certificate problem: unable to get local issuer certificate", unlist(lapply(resps, get_curl_err))))) {
      cat("\n")
      cli_alert_danger("Could not verify SSL certificate.")
      cli::cli_text("You may have success running {.fn set_ohvbd_compat} and then trying again.")
      cat("\n")
      cli_abort("SSL certificate problem: unable to get local issuer certificate")
    }
    cli_alert_warning("No records retrieved (are you sure the IDs are correct?).")
  }

  resps <- new_ohvbd.responses(l = resps, db = "vd")

  return(resps)
}
