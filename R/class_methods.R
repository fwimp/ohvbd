# nolint start: object_name_linter

# Printers

#' @export
print.ohvbd.ids <- function(x, ...) {
  cli::cat_line(cli::format_inline("{.cls {class(x)[1]}}"))
  cat(paste0("Database: ", attr(x, "db"), "\n"))
  if (is.numeric(x)) {
    print(as.numeric(x))
  } else {
    print(as.character(x))
  }
  invisible(x)
}

#' @export
print.ohvbd.data.frame <- function(x, ...) {
  cli::cat_line(cli::format_inline("{.cls {class(x)[1]}}"))
  cat(paste0("Database: ", attr(x, "db"), "\n"))
  print(as.data.frame(x))
  invisible(x)
}

#' @export
print.ohvbd.ad.matrix <- function(x, ..., full = FALSE) {
  cli::cat_line(cli::format_inline("{.cls {class(x)[1]}}"))
  # TODO: Possibly worthwhile moving most of this to a new summary.ohvbd.ad.matrix function?
  # If attr is null, default to <missing>
  metric <- attr(x, 'metric') %||% '<missing>'
  gid <- attr(x, 'gid') %||% '<missing>'
  cached <- attr(x, 'cached') %||% 'unknown'
  startdate <- head(colnames(x), 1) %||% 'unknown'
  enddate <- tail(colnames(x), 1) %||% 'unknown'
  if (!is.null(options("cli.default_handler"))) {
    cat(paste("Areadata matrix for", metric, "at gid level", gid, ".\n"))
    cat(paste("Cached:", cached, "\n"))
    cat(paste("Dates:", startdate, "->", enddate, paste0("(", ncol(x), ")\n")))
    cat(paste("Locations:", nrow(x), "\n"))
    if (full) {
      cat("Data:\n")
      NextMethod(object = matrix())
    }
  } else {
    cli::cli_text(
      "Areadata matrix for {.val {metric}} at gid level {.val {gid}}."
    )
    cli::cli_text("Cached: {.val {cached}}")
    cli::cli_text(
      "Dates: {.val {startdate}} -> {.val {enddate}} ({.val {ncol(x)}})"
    )
    cli::cli_text("Locations: {.val {nrow(x)}}")
    if (full) {
      cli::cli_h1("Data")
      NextMethod(object = matrix())
    }
  }
  invisible(x)
}

#' @export
print.ohvbd.hub.search <- function(x, ...) {
  cli::cat_line(cli::format_inline("{.cls {class(x)[1]}}"))
  cat(paste0("Rows: ", nrow(x), ", Query: ", attr(x, "query"), "\n"))
  print(as.data.frame(x))
  invisible(x)
}

#' @export
summary.ohvbd.hub.search <- function(object, ...) {
  # fmt: skip
  cat(paste0("Rows: ", nrow(object) , ", Query: ", attr(object, "query"), "\n\nSplit by database:"))
  print(table(object$db))
  invisible(object)
}

# Indexers

#' @export
`[.ohvbd.ids` <- function(x, i) {
  new_ohvbd.ids(NextMethod(), db = attr(x, "db"))
}

#' @title Fetch specified data from a set of ids
#'
#' @description
#' This is a convenience method that infers and applies the correct fetch function for the input ids.
#' @author Francis Windram
#'
#' @param ids An object of type `ohvbd.ids` (generated from a search, manually packaged using [ohvbd.ids()] or generated by another function).
#' @param ... Any other arguments to be passed to the underlying fetch functions (see [fetch_vt()] and [fetch_vd()] for specific arguments).
#' @returns The downloaded data, as an `ohvbd.responses` object.
#' @concept convenience
#' @export
#' @examplesIf interactive()
#' find_vt_ids() |> fetch()
#'
fetch <- function(
  ids,
  ...
) {
  UseMethod("fetch")
}

#' @export
fetch.ohvbd.ids <- function(
  ids,
  ...
) {
  db <- list(...)$db
  if (is.null(db)) {
    # If not overriding db, just use the one provided
    db <- attr(ids, "db")
  }
  finalfun <- switch(
    db,
    "vt" = fetch_vt,
    "vd" = fetch_vd,
    "gbif" = fetch_gbif,
    cli::cli_abort(
      "No method to fetch data from DB {.val {db}} for class{?es} {.cls {class(x)}}"
    )
  )
  return(finalfun(ids, ...))
}

#' @export
fetch.ohvbd.hub.search <- function(
  ids,
  ...
) {
  # Could consider in the future making this method parse the individual dbs
  # and run their respective fetchers, but this would add a lot of complexity
  # when it comes to gleaning.
  cli::cli_abort(c(
    "x" = "Cannot fetch an {.cls ohvbd.hub.search} object!",
    "!" = "Did you forget to use {.fn ohvbd::filter_db} after searching?"
  ))
}

#' @title Extract specified data from a set of responses
#'
#' @description
#' This is a convenience method that infers and applies the correct extractor for the input
#' @author Francis Windram
#'
#' @param res An object of type `ohvbd.responses` or `ohvbd.ad.matrix` generated from [fetch()]
#' and containing data from one of the supported databases.
#' @param ... Any arguments to be passed to the underlying extractors (see [glean_vt()] and [glean_ad()] for specific arguments).
#' @returns The extracted data, either as an `ohvbd.data.frame` or `ohvbd.ad.matrix` object.
#' @concept convenience
#' @export
#' @examplesIf interactive()
#' find_vt_ids() |> fetch() |> glean(cols=c("Interactor1Species"))
#' fetch_ad(use_cache=TRUE) |> glean(targetdate="2020-08-04")
#'
glean <- function(res, ...) {
  UseMethod("glean")
}

#' @export
glean.ohvbd.responses <- function(
  res,
  ...,
  cols = NA,
  returnunique = FALSE,
  db = NULL
) {
  if (is.null(db)) {
    # If not overriding db, just use the one provided
    db <- attr(res, "db")
  }
  finalfun <- switch(
    db,
    "vt" = glean_vt,
    "vd" = glean_vd,
    "gbif" = glean_gbif,
    cli::cli_abort(
      "No method to extract data from DB {.val {db}} for class{?es} {.cls {class(x)}}"
    )
  )
  return(finalfun(res, cols, returnunique))
}

#' @export
glean.ohvbd.ad.matrix <- function(
  res,
  ...,
  targetdate = NA,
  enddate = NA,
  places = NA,
  gid = NA
) {
  db <- attr(res, "db")
  return(glean_ad(res, targetdate, enddate, places, gid))
}

#' @export
glean.ohvbd.ids <- function(
  res,
  ...
) {
  # Could consider in the future making this method parse the individual dbs
  # and run their respective fetchers, but this would add a lot of complexity
  # when it comes to gleaning.
  cli::cli_abort(c(
    "x" = "Cannot glean an {.cls ohvbd.ids} object!",
    "!" = "Did you forget to use {.fn ohvbd::fetch} after searching?"
  ))
}
# nolint end
